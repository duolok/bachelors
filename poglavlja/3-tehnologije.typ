#import "../funkcije.typ": todo
= Технологије
<технологије>

Развој ефикасног, поузданог и одрживог система за мониторинг захтева пажљив избор технологија које омогућавају високе перформансе,
безбедност и флексибилност. Ова имплементација се базира на коришћењу модерног Раст екосистема.
Овај одељак описује главне технологије коришћене у имплементацији: _Раст_ (енг. _Rust_) програмски језик као основу целокупног пројекта @rust-book,
_Tokio_ асинхрони _runtime_ за неблокирајућу обраду података @tokio, _Ratatui_ библиотеку за креирање корисничког интерфејса у терминалу @ratatui,
и _Crossterm_ библиотеку за вишеплатформску манипулацију терминала @crossterm. Заједно, ове технологије чине робустан систем који
омогућава прикупљање и приказивање системских метрика у реалном времену са минималним оптерећењем система.

== Раст, програмски језик

*Раст* (енг. _Rust_) је системски програмски језик опште намене (енг. _general-purpose_) код кога се посебна пажња посвећује перформансама,
безбедности типова (енг. _type safety_), безбедности меморије (енг. _memory safety_) и конкурентности @rust-book.

Раст подржава више програмских стилова, а многе његове синтаксне и концептуалне особине као што су рад са
непроменљивим подацима, коришћење функција вишег реда, алгебарских типова и подударања образаца (енг. _pattern matching_), потичу из
функционалних језика. Истовремено, Раст омогућава и објектно-оријентисан начин програмирања преко структура,
енумерација, трејтова и метода @rust-reference.

Познат је по строгом приступу меморијској безбедности, све референце морају бити валидне.
То се постиже без коришћења традиционалног сакупљача ђубрета (енг. _garbage collector_). Уместо тога, Раст користи свој интерни
позајмљивач (енг. _borrow checker_), механизам који већ током компилације прати области важења (енг. _scope_) и животни век (енг. _lifetime_)
свих објеката, што спречава уобичајене грешке у руковању меморијом и појаву трке до података (енг. _data race_).

=== Власништво

Кључна особина која Раст разликује од других програмских језика је његов систем *власништва* (енг. _ownership_) @rust-book. 
Свака вредност у Раст-у има тачно једног "власника", променљиву или структуру која контролише њен животни век. 
Када власник изађе из области важења, вредност се аутоматски ослобађа. Ово правило елиминише проблеме попут двоструког 
ослобађања меморије (енг. _double-free_) и коришћења меморије након ослобађања (енг. _use-after-free_).

=== Позајмљивање

Поред власништва, Раст уводи концепт *позајмљивања* (енг. _borrowing_) који омогућава привремени приступ подацима без
преношења власништва. Постоје два типа позајмљивања: непроменљиво позајмљивање (енг. _immutable borrow_) означено са `&T`, 
које дозвољава само читање, и променљиво позајмљивање (енг. _mutable borrow_) означено са `&mut T`, које дозвољава и читање и писање. 
Компајлер гарантује да у било ком тренутку може постојати или више непроменљивих позајмљивања или тачно једно променљиво 
позајмљивање, али не оба истовремено.

=== Животни век

*Животни век* (енг. _lifetime_) је Раст-ова апстракција која описује колико дуго је референца валидна. Иако се у већини случајева
животни век аутоматски закључује од стране компајлера (енг. _lifetime elision_), понекад је потребно експлицитно дефинисати животни
век референци. Животни век се означава апострофом и генеричким параметром. Компајлер користи ове анотације да провери да ли су референце
валидне у тренутку када се користе. Циљ је спречити ситуације где би референца могла да показује на меморију која је већ ослобођена, такође
познати као висећи показивачи.

=== Висећи показивачи 

*Висећи показивач* (енг. _dangling pointer_) је референца која показује на меморијску адресу која више није валидна, обично зато што је објекат на који је показивала
ослобођен из меморије. Ово је једна од честих рањивости у језицима са ручним управљањем меморијом, као што су Ц и Ц++, која може довести до
повећавања привилегија (енг. _privilege escalation_) или до цурења информација уколико се показивач користи за писање у меморију. 

== `Tokio`

*Tokio* @tokio је асинхрони извршни оквир (енг. _async runtime_) за Раст који омогућава писање неблокирајућих апликација. Пружа инфраструктуру за 
извршавање асинхроних задатака (енг. _async tasks_).

=== Асинхрони модел извршавања 

Раст имплементира асинхроно програмирање кроз `async/await` синтаксу @rust-async-book. Функције означене кључном речју `async` враћају објекат типа `Future` који 
представља вредност која ће бити доступна у будућности. Раст-ови `Future` типови су лењи (енг. _lazy_) - не извршавају се аутоматски, већ морају 
бити експлицитно покренути позивањем методе `poll` или извршавањем кроз оквир као што је `Tokio`.

`Tokio` користи планер (енг. _scheduler_) заснован на алгоритму крађе посла (енг. _work-stealing scheduler_) @tokio-tutorial, који ефикасно распоређује 
асинхроне задатке на доступне нити. Свако језгро (енг. _core_) има свој ред (енг. _queue_) задатака који извршава. Када је ред празан, језгро
проверава задатке од преосталих језгара и преузима њихов посао. Језгро ће отићи у стање спавања ако не може да пронађе задатак који би требало 
да се извршава.

`Tokio` такође пружа примитиве за синхронизацију између задатака, попут канала (енг. _channel_) и брава (енг. _mutex_), која се у овом раду 
користе за безбедну комуникацију између компоненти за прикупљање података и компоненти за приказ.

У овој имплементацији, `Tokio` се користи за неблокирајуће прикупљање метрика из различитих извора. Свака компонента за прикупљање података 
ради као асинхрони задатак који периодично чита системске метрике. 

== `Ratatui`

*Ratatui* @ratatui је Растова библиотека за креирање корисничког интерфејса за терминал (енг. _Terminal User Interface_).

=== Рендеровање 

Када разговарамо о развоју корисничког интерфејса, разликујемо две главне парадигме: режим тренутног рендеровања (енг. _immediate mode rendering_) и 
режим задржаног рендеровања (енг. _retained mode rendering_).

- *Режим тренутног рендеровања* се заснива на исцртавању корисничког интерфејса за слику (енг. _frame_) која означава промену стања апликације. Не постоје објекти који се трајно чувају у меморији.

- *Режим задржаног рендеровања* се заснива на креирању _виџет_ (енг. _widget_) објеката који интерно чувају своје стање, а који се касније појединачно модификују у зависности од стања апликације.

`Ratatui` користи режим тренутног рендеровања са посредним баферима. Ово значи да апликација за сваку слику мора експлицитно рендеровати све 
виџете који треба да буду приказани. Иако овај приступ може изгледати неефикасно, `Ratatui` оптимизује рендеровање користећи двобуферски систем.
Нови садржај се исцртава у позадински бафер, а затим се врши поређење (енг. _diffing_) са предњим бафером који је тренутно приказан на екрану.
На терминал се шаљу само ANSI escape секвенце за промене између два бафера, што значајно смањује количину података која се мора пренети.


=== Систем виџета

`Ratatui` пружа богат скуп уграђених виџета који се могу комбиновати за изградњу сложених интерфејса @ratatui-widgets:

- *Block* — основни градивни елемент који дефинише правоугаону област са границама и насловом
- *Paragraph* — приказ текстуалног садржаја са подршком за стилизовање
- *List* — вертикална листа ставки са подршком за селекцију и скроловање
- *Table* — табеларни приказ података са подршком за заглавља, сортирање и селекцију редова
- *Chart* — линијски и бар графикони за визуелизацију временских серија
- *Gauge* — индикатори напредка и искоришћености ресурса
- *Tabs* — компонента за навигацију између различитих приказа

За целокупну листу виџета, потребно је погледати документацију. 
Сваки виџет имплементира `Widget` trait који дефинише методу `render` за исцртавање виџета на датој правоугаоној области терминала.
Виџети се могу угнездити једни у друге, што омогућава креирање сложених распореда.

== `Crossterm`

*Crossterm* @crossterm је Раст библиотека за манипулацију терминалом која омогућава писање вишеплатформских текстуалних 
интерфејса. Подржава UNIX и Windows терминале.

=== Апстракција функција терминала

Crossterm пружа API за рад са терминалом који апстрахује разлике између различитих оперативних система и 
емулатора терминала. На UNIX системима, Crossterm користи ANSI escape секвенце за контролу терминала, док на 
Windows-у користи Windows Console API функције. Ова апстракција омогућава да исти код ради на свим подржаним платформама 
без измена.

Главне области функционалности које Crossterm пружа су:

*Управљање курсором* — Crossterm омогућава померање курсора на произвољне позиције, сакривање и приказивање курсора, 
чување и враћање позиције курсора, као и контролу трептања курсора.

*Стилизовање текста* — Подршка за боје текста и позадине, као и атрибуте текста попут 
подебљавања, италика, подвлачења, и других ефеката.

*Управљање терминалом* — Чишћење екрана или појединачних линија, улазак у сирови режим (енг. _raw mode_) за читање 
сваког притиска тастера појединачно, и добијање димензија терминала.

*Обрада догађаја* — Читање догађаја са тастатуре и миша у блокирајућем или неблокирајућем режиму, са подршком за 
детектовање модификаторских тастера (Ctrl, Alt, Shift).

=== Интеграција са Ratatui библиотеком

Иако `Ratatui` пружа апстракцију вишег нивоа за креирање корисничких интерфејса, он се ослања на библиотеке нижег 
нивоа попут Crossterm-а за стварну интеракцију са терминалом @crossterm. `Ratatui` подржава више _backend_-а (Crossterm, Termion @termion, Termwiz @termwiz), 
али је Crossterm подразумевани избор због своје вишеплатформске подршке и богатог скупа функција. Ова архитектура 
омогућава `Ratatui`-ју да се фокусира на логику приказа и распореда виџета, док Crossterm брине о детаљима 
као што су слање ANSI секвенци, управљање баферима и комуникација са оперативним системом.
